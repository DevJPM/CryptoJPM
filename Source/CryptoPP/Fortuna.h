// Fortuna.h - written and placed in the public domain by Jean-Pierre Muench

#ifndef CRYPTOPP_FORTUNA_H
#define CRYPTOPP_FORTUNA_H

#include "cryptlib.h"
#include "filters.h"
#include "aes.h"
#include "sha.h"
#include "hrtimer.h"

NAMESPACE_BEGIN(CryptoPP)

class CRYPTOPP_NO_VTABLE Fortuna_Base : public RandomNumberGenerator, public NotCopyable
{
public:
	CRYPTOPP_CONSTANT(MIN_POOL_SIZE = 64)
	CRYPTOPP_CONSTANT(MAX_EVENT_SIZE = 32) // should be a power of 2
	CRYPTOPP_CONSTANT(NUM_POOLS = 32)
	CRYPTOPP_CONSTANT(NUMBER_MILLISECONDS_BETWEEN_RESEEDS = 100)
public:
	Fortuna_Base();

	std::string AlgorithmName() const {return "Fortuna";}

	void IncorporateEntropy(const byte* Input,size_t length) {IncorporateEntropyEx(Input,length,0);}
	void IncorporateEntropyEx(const byte* Input,size_t length,byte SourceNumber);
	bool CanIncorporateEntropy() const {return true;}
	// maximal amount of bytes to be generated by GenerateSmallBlock()
	size_t MaxGenerateSize() const;
	// throws if size > MaxGenerateSize
	void GenerateSmallBlock(byte* output,size_t size);
	// calls GenerateSmallBlock() multiple times to gather the data
	void GenerateBlock(byte* output,size_t size);

	virtual void GenerateSeedFile(byte* output,size_t length) {GenerateBlock(output,length);}
	// create a new seed file after you've used the old one
	virtual void ReadSeedFile(const byte* input,size_t length) {Reseed(input,length);}
protected:
	void IncorporateEntropySmall(const byte* Input,byte length,byte SourceNumber);
	void Reseed(const byte* NewSeed,size_t seedlen);
	virtual HashTransformation& GetPoolHash(byte i) =0;
	virtual HashTransformation& GetReseedHash() =0;
	virtual BlockCipher* GetCipher() =0;
	// can't modify state here
	virtual const BlockCipher* GetCipher() const =0;
private:
	SecByteBlock m_Key;
	SecByteBlock m_Counter;
	word64 m_ReseedCounter;
	byte m_PoolIndex;
	FixedSizeSecBlock<word64,32> m_PoolProcessedData;
	ThreadUserTimer m_ReseedTimer;
};

// note: digestsize of reseed hash must be longer than max keylength of the cipher
template<class CIPHER,class RESEED_HASH,class POOL_HASH = RESEED_HASH>
class Fortuna : public Fortuna_Base
{
public:
	Fortuna():Fortuna_Base(){}
private:
	POOL_HASH m_PoolHashes[32];
	RESEED_HASH m_ReseedHash;
	typename CIPHER::Encryption m_UsedCipher;
	const typename CIPHER::Encryption m_InfoCipher;
	HashTransformation& GetPoolHash(byte i) {if(i>=NUM_POOLS){throw(InvalidArgument("can not access a Fortuna-Pool beyond 32!"));}return m_PoolHashes[i];}
	HashTransformation& GetReseedHash() {return m_ReseedHash;}
	BlockCipher* GetCipher() {return &m_UsedCipher;}
	const BlockCipher* GetCipher() const {return &m_InfoCipher;}
};

// the original scrypt as specified by Schneier, Fergueson and Kohno
typedef Fortuna<AES,SHA256> OriginalFortuna;

NAMESPACE_END

#endif